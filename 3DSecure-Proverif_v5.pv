(* Types *)
type key.
type skey [private].
type pkey.
type nonce.

(* Participants *)
const C: bitstring.       (* Customer *)
const M: bitstring.       (* Merchant *)
const ACS: bitstring.     (* Access Control Server *)

(* Channels *)
free c: channel.

(* Pairing *)
fun pair(bitstring, bitstring): bitstring.
reduc forall x: bitstring, y: bitstring; fst(pair(x, y)) = x.
reduc forall x: bitstring, y: bitstring; snd(pair(x, y)) = y.

(* Cryptographic Primitives *)

(* Functions for Making Natural Numbers *)
reduc forall x:nat; nat_init(x) = x.

fun nat_to_bitstring(nat): bitstring [data,typeConverter].
fun nonce_to_bitstring(nonce): bitstring [data,typeConverter].

(* Symmetric Encryption and Decryption with Nonce *)
fun senc(key, nonce, bitstring): bitstring.
reduc forall k: key, n: nonce, m: bitstring; sdec(k, n, senc(k, n, m)) = m.

(* Message Authentication Code (MAC) *)
fun mac(key, bitstring): bitstring.

(* Asymmetric Key Functions *)
fun pk(skey): pkey.
fun sign(bitstring, skey): bitstring.
reduc forall m: bitstring, sk: skey; checksign(sign(m, sk), pk(sk)) = m.

(* Authenticated Encryption with Associated Data (AEAD) *)
letfun aeadenc(k:key, n:nonce, plaintext:bitstring) =
    (senc(k,n,plaintext), mac(k,(n,senc(k,n,plaintext)))).
letfun aeaddec(k:key, n:nonce, ciphertext:bitstring, tag:bitstring) =
    let (=tag) =mac(k,(n,ciphertext)) in
    let plaintext:bitstring = sdec(k,n,ciphertext) in
    plaintext.

(* Secrets *)
free pan: bitstring [private].
free expiry: bitstring [private].
free securecode: bitstring [private].

(* Tables for Nonce Tracking *)
table NonceTableMerchantToCustomer(nonce, bitstring).
table NonceTableCustomerToACS(nonce, bitstring).
table NonceTableACSToCustomer(nonce, bitstring).
table NonceTableMerchantToACS(nonce, bitstring).
table NonceTableCustomerToMerchant(nonce, bitstring).
table NonceTableACSToMerchant(nonce, bitstring).

(* Events for authentication queries *)
event send_purchaseRequestEnc(bitstring, nonce, bitstring, bitstring).
event receive_purchaseRequestEnc(bitstring, nonce, bitstring, bitstring).
event send_transactionDetailsEnc(bitstring, nonce, bitstring).
event receive_transactionDetailsEnc(bitstring, nonce, bitstring).
event send_transactionDetailsEnc2(bitstring, nonce, bitstring).
event receive_transactionDetailsEnc2(bitstring, nonce, bitstring).
event send_authRequestEnc(bitstring, nonce, bitstring).
event receive_authRequestEnc(bitstring, nonce, bitstring).
event send_securecodeEnc(bitstring, nonce, bitstring).
event receive_securecodeEnc(bitstring, nonce, bitstring).
event send_authResponse(bitstring, nonce, bitstring).
event receive_authResponse(bitstring, nonce, bitstring).
event forward_authResponse(bitstring, nonce, bitstring).
event receive_forward_authResponse(bitstring, nonce, bitstring).
event send_confirmation(bitstring, nonce, bitstring).
event receive_confirmation(bitstring, nonce, bitstring).
event invalid_sender(nonce).
event invalid_signature(bitstring).
event invalid_mac(bitstring).
event reach.


(* Customer Process *)
let processCustomer(SK_C: skey, PK_M: pkey, PK_ACS: pkey, keyCM: key, keyAC: key) =
    new SessionID: bitstring;        (* SessionID generated by Customer *)
    new nonceC1: nonce;              (* Nonce generated by Customer for Merchant *)
    let counter_C_M: nat = 0 in      (* Counter for messages from Customer to Merchant *)
    let counter_M_C: nat = 0 in      (* Counter for messages from Merchant to Customer *)
    let counter_C_ACS: nat = 0 in    (* Counter for messages from Customer to ACS *)
    let counter_ACS_C: nat = 0 in    (* Counter for messages from ACS to Customer *)

    (* Step 1: Customer sends purchase request to Merchant *)
    let purchaseRequest = pair(pan, pair(expiry, pair(nonce_to_bitstring(nonceC1), pair(C, pair(SessionID, nat_to_bitstring(counter_C_M)))))) in
    let signature_C = sign(purchaseRequest, SK_C) in
    new n1: nonce;
    let purchaseRequestEnc = aeadenc(keyCM, n1, pair(purchaseRequest, signature_C)) in
    event send_purchaseRequestEnc(purchaseRequestEnc, nonceC1, C, SessionID);
    out(c, purchaseRequestEnc);
    (* Increment counter *)
    let counter_C_M = counter_C_M + 1 in

    (* Step 2: Customer receives transaction details from Merchant *)
    in(c, transactionDetailsEnc: bitstring);
    new n2: nonce;
    let plaintext = aeaddec(keyCM, n2, transactionDetailsEnc) in
    let transactionDetailsMessage = fst(plaintext) in
    let signature_M = snd(plaintext) in
    (* Verify Merchant's signature *)
    if checksign(signature_M, PK_M) = transactionDetailsMessage then
        let SessionID_received = fst(transactionDetailsMessage) in
        let rest1 = snd(transactionDetailsMessage) in
        let M_received = fst(rest1) in
        let rest2 = snd(rest1) in
        let nonceM1_received = fst(rest2) in
        let rest3 = snd(rest2) in
        let nonceC1_received = fst(rest3) in
        let counter_M_C_received = snd(rest3) in
        if SessionID_received = SessionID && M_received = M && nonceC1_received = nonceC1 && counter_M_C_received = counter_M_C then
            (* Increment counter *)
            let counter_M_C = counter_M_C + 1 in
            (* Check if nonceM1 has been used before *)
            get NonceTableMerchantToCustomer(nonce, session) suchthat nonce = nonceM1_received && session = SessionID in
                event invalid_sender(nonceM1_received);
                0
            else
                insert NonceTableMerchantToCustomer(nonceM1_received, SessionID);
                event receive_transactionDetailsEnc(transactionDetailsEnc, nonceC1, SessionID_received);
                (* Step 3: Customer sends transaction details to ACS *)
                new nonceC2: nonce;        (* Nonce generated by Customer for ACS *)
                let transactionDetailsForACS = pair(SessionID, pair(M, counter_C_ACS)) in
                let messageForACS = pair(transactionDetailsForACS, pair(nonceC2, C)) in
                let signature_C_ACS = sign(messageForACS, SK_C) in
                new n3: nonce;
                let transactionDetailsEnc2 = aeadenc(keyAC, n3, pair(messageForACS, signature_C_ACS)) in
                event send_transactionDetailsEnc2(transactionDetailsEnc2, nonceC2, SessionID);
                out(c, transactionDetailsEnc2);
                (* Increment counter *)
                let counter_C_ACS = counter_C_ACS + 1 in

                (* Step 4: Customer receives auth request from ACS *)
                in(c, authRequestEnc: bitstring);
                new n4: nonce;
                let plaintext_auth = aeaddec(keyAC, n4, authRequestEnc) in
                let authRequestMessage = fst(plaintext_auth) in
                let signature_ACS = snd(plaintext_auth) in
                (* Verify ACS's signature *)
                if checksign(signature_ACS, PK_ACS) = authRequestMessage then
                    let SessionID_received_ACS = fst(authRequestMessage) in
                    let rest1 = snd(authRequestMessage) in
                    let ACS_received = fst(rest1) in
                    let rest2 = snd(rest1) in
                    let nonceACS_received = fst(rest2) in
                    let rest3 = snd(rest2) in
                    let nonceC2_received = fst(rest3) in
                    let counter_ACS_C_received = snd(rest3) in
                    if SessionID_received_ACS = SessionID && ACS_received = ACS && nonceC2_received = nonceC2 && counter_ACS_C_received = counter_ACS_C then
                        (* Increment counter *)
                        let counter_ACS_C = counter_ACS_C + 1 in
                        (* Check if nonceACS has been used before *)
                        get NonceTableACSToCustomer(nonce, session) suchthat nonce = nonceACS_received && session = SessionID in
                            event invalid_sender(nonceACS_received);
                            0
                        else
                            insert NonceTableACSToCustomer(nonceACS_received, SessionID);
                            event receive_authRequestEnc(authRequestEnc, nonceC2, SessionID_received_ACS);
                            (* Step 5: Customer sends secure code to ACS *)
                            new nonceC3: nonce;        (* Nonce generated by Customer for ACS *)
                            let securecodeMessage = pair(securecode, pair(nonceACS_received, pair(nonceC3, SessionID))) in
                            let signature_C_securecode = sign(securecodeMessage, SK_C) in
                            new n5: nonce;
                            let securecodeEnc = aeadenc(keyAC, n5, pair(securecodeMessage, signature_C_securecode)) in
                            event send_securecodeEnc(securecodeEnc, nonceACS_received, SessionID);
                            out(c, securecodeEnc);
                            (* Increment counter *)
                            let counter_C_ACS = counter_C_ACS + 1 in

                            (* Step 6: Customer receives auth response from ACS *)
                            in(c, authResponseEnc: bitstring);
                            new n6: nonce;
                            let plaintext_auth_resp = aeaddec(keyAC, n6, authResponseEnc) in
                            let authResponseMessage = fst(plaintext_auth_resp) in
                            let signature_ACS_resp = snd(plaintext_auth_resp) in
                            (* Verify ACS's signature *)
                            if checksign(signature_ACS_resp, PK_ACS) = authResponseMessage then
                                let SessionID_received_resp = fst(authResponseMessage) in
                                let rest1 = snd(authResponseMessage) in
                                let messageAuth = fst(rest1) in
                                let rest2 = snd(rest1) in
                                let nonceACS2_received = fst(rest2) in
                                let rest3 = snd(rest2) in
                                let nonceACS_received_resp = fst(rest3) in
                                let rest4 = snd(rest3) in
                                let nonceC3_received_resp = fst(rest4) in
                                let counter_ACS_C_received_resp = snd(rest4) in
                                if SessionID_received_resp = SessionID && nonceACS_received_resp = nonceACS_received && nonceC3_received_resp = nonceC3 && counter_ACS_C_received_resp = counter_ACS_C then
                                    (* Increment counter *)
                                    let counter_ACS_C = counter_ACS_C + 1 in
                                    (* Check if nonceACS2 has been used before *)
                                    get NonceTableACSToCustomer(nonce, session) suchthat nonce = nonceACS2_received && session = SessionID in
                                        event invalid_sender(nonceACS2_received);
                                        0
                                    else
                                        insert NonceTableACSToCustomer(nonceACS2_received, SessionID);
                                        event receive_authResponse(authResponseEnc, nonceACS2_received, SessionID_received_resp);
                                        (* Step 7: Customer sends auth response to Merchant *)
                                        new nonceC4: nonce;        (* Nonce generated by Customer for Merchant *)
                                        let authResponseForMerchant = pair(authResponseMessage, pair(SessionID, nonceC4)) in
                                        let signature_C_M = sign(authResponseForMerchant, SK_C) in
                                        new n7: nonce;
                                        let authResponseEnc2 = aeadenc(keyCM, n7, pair(authResponseForMerchant, signature_C_M)) in
                                        event forward_authResponse(authResponseEnc2, nonceC4, SessionID_received_resp);
                                        out(c, authResponseEnc2);
                                        (* Increment counter *)
                                        let counter_C_M = counter_C_M + 1 in

                                        (* Step 8: Customer receives confirmation from Merchant *)
                                        in(c, confEnc: bitstring);
                                        new n8: nonce;
                                        let plaintext_conf = aeaddec(keyCM, n8, confEnc) in
                                        let confirmationMessage = fst(plaintext_conf) in
                                        let signature_M_conf = snd(plaintext_conf) in
                                        (* Verify Merchant's signature *)
                                        if checksign(signature_M_conf, PK_M) = confirmationMessage then
                                            let cconfirm = fst(confirmationMessage) in
                                            let rest1 = snd(confirmationMessage) in
                                            let SessionID_received_conf = fst(rest1) in
                                            let rest2 = snd(rest1) in
                                            let nonceM2_received = fst(rest2) in
                                            let rest3 = snd(rest2) in
                                            let nonceM1_received_conf = fst(rest3) in
                                            let counter_M_C_received_conf = snd(rest3) in
                                            if SessionID_received_conf = SessionID && nonceM1_received_conf = nonceM1_received && counter_M_C_received_conf = counter_M_C then
                                                (* Increment counter *)
                                                let counter_M_C = counter_M_C + 1 in
                                                (* Check if nonceM2 has been used before *)
                                                get NonceTableMerchantToCustomer(nonce, session) suchthat nonce = nonceM2_received && session = SessionID in
                                                    event invalid_sender(nonceM2_received);
                                                    0
                                                else
                                                    insert NonceTableMerchantToCustomer(nonceM2_received, SessionID);
                                                    event receive_confirmation(confEnc, nonceM2_received, SessionID_received_conf);
                                                    event reach;
                                                    0
                                            else
                                                event invalid_sender(nonceM1_received_conf);
                                                0
                                        else
                                            event invalid_signature(signature_M_conf);
                                            0
                                else
                                    event invalid_sender(nonceACS_received_resp);
                                    0
                            else
                                event invalid_signature(signature_ACS_resp);
                                0
                    else
                        event invalid_sender(nonceC2_received);
                        0
                else
                    event invalid_signature(signature_ACS);
                    0
        else
            event invalid_sender(nonceM1_received);
            0
    else
        event invalid_signature(signature_M);
        0
    .


(* Merchant Process *)
let processMerchant(PK_C: pkey, SK_M: skey, PK_ACS: pkey, keyCM: key) =
    let counter_C_M: nat = 0 in      (* Counter for messages from Customer to Merchant *)
    let counter_M_C: nat = 0 in      (* Counter for messages from Merchant to Customer *)

    (* Step 1: Merchant receives purchase request from Customer *)
    in(c, purchaseRequestEnc: bitstring);
    new n1: nonce;
    let plaintext = aeaddec(keyCM, n1, purchaseRequestEnc) in
    let purchaseRequest = fst(plaintext) in
    let signature_C = snd(plaintext) in
    (* Verify Customer's signature *)
    if checksign(signature_C, PK_C) = purchaseRequest then
        let pan_received = fst(purchaseRequest) in
        let rest1 = snd(purchaseRequest) in
        let expiry_received = fst(rest1) in
        let rest2 = snd(rest1) in
        let nonceC1_received = fst(rest2) in
        let rest3 = snd(rest2) in
        let sender_received = fst(rest3) in
        let rest4 = snd(rest3) in
        let SessionID_received = fst(rest4) in
        let counter_C_M_received = snd(rest4) in
        if sender_received = C && counter_C_M_received = counter_C_M then
            (* Increment counter *)
            let counter_C_M = counter_C_M + 1 in
            (* Check if nonceC1 has been used before *)
            get NonceTableCustomerToMerchant(nonce, session) suchthat nonce = nonceC1_received && session = SessionID_received in
                event invalid_sender(nonceC1_received);
                0
            else
                insert NonceTableCustomerToMerchant(nonceC1_received, SessionID_received);
                event receive_purchaseRequestEnc(purchaseRequestEnc, nonceC1_received, sender_received, SessionID_received);
                (* Step 2: Merchant sends transaction details to Customer *)
                new nonceM1: nonce;        (* Nonce generated by Merchant *)
                let transactionDetailsMessage = pair(SessionID_received, pair(M, pair(nonceM1, pair(nonceC1_received, counter_M_C)))) in
                let signature_M = sign(transactionDetailsMessage, SK_M) in
                new n2: nonce;
                let transactionDetailsEnc = aeadenc(keyCM, n2, pair(transactionDetailsMessage, signature_M)) in
                event send_transactionDetailsEnc(transactionDetailsEnc, nonceC1_received, SessionID_received);
                out(c, transactionDetailsEnc);
                (* Increment counter *)
                let counter_M_C = counter_M_C + 1 in

                (* Step 7: Merchant receives auth response from Customer *)
                in(c, authResponseEnc2: bitstring);
                new n3: nonce;
                let plaintext_resp = aeaddec(keyCM, n3, authResponseEnc2) in
                let authResponseForMerchant = fst(plaintext_resp) in
                let signature_C_resp = snd(plaintext_resp) in
                (* Verify Customer's signature *)
                if checksign(signature_C_resp, PK_C) = authResponseForMerchant then
                    let authResponseMessageContent = fst(authResponseForMerchant) in
                    let rest1 = snd(authResponseForMerchant) in
                    let SessionID_received_resp = fst(rest1) in
                    let nonceC4_received = snd(rest1) in

                    let SessionID_authResponse = fst(authResponseMessageContent) in
                    let rest2 = snd(authResponseMessageContent) in
                    let messageAuth = fst(rest2) in
                    let rest3 = snd(rest2) in
                    let nonceACS2_received = fst(rest3) in
                    let rest4 = snd(rest3) in
                    let nonceACS_received = fst(rest4) in
                    let counter_ACS_C_received = snd(rest4) in

                    if SessionID_received_resp = SessionID_received && SessionID_authResponse = SessionID_received then
                        (* Increment counter *)
                        let counter_C_M = counter_C_M + 1 in
                        (* Check if nonceC4 and nonceACS2 have been used before *)
                        get NonceTableCustomerToMerchant(nonce, session) suchthat nonce = nonceC4_received && session = SessionID_received in
                            event invalid_sender(nonceC4_received);
                            0
                        else
                            get NonceTableACSToMerchant(nonce, session) suchthat nonce = nonceACS2_received && session = SessionID_received in
                                event invalid_sender(nonceACS2_received);
                                0
                            else
                                insert NonceTableACSToMerchant(nonceACS2_received, SessionID_received);
                                event receive_forward_authResponse(authResponseEnc2, nonceACS2_received, SessionID_received_resp);
                                (* Step 8: Merchant sends confirmation to Customer *)
                                new cconfirm: bitstring;
                                new nonceM2: nonce;        (* Nonce generated by Merchant *)
                                let confirmationMessage = pair(cconfirm, pair(SessionID_received, pair(nonceM2, pair(nonceM1, counter_M_C)))) in
                                let signature_M_conf = sign(confirmationMessage, SK_M) in
                                new n4: nonce;
                                let confEnc = aeadenc(keyCM, n4, pair(confirmationMessage, signature_M_conf)) in
                                event send_confirmation(confEnc, nonceM2, SessionID_received);
                                out(c, confEnc);
                                (* Increment counter *)
                                let counter_M_C = counter_M_C + 1 in
                                0
                    else
                        event invalid_sender(SessionID_received_resp);
                        0
                else
                    event invalid_signature(signature_C_resp);
                    0
        else
            event invalid_sender(nonceC1_received);
            0
    else
        event invalid_signature(signature_C);
        0
    .


(* ACS Process *)
let processACS(PK_C: pkey, SK_ACS: skey, PK_M: pkey, keyAC: key) =
    let counter_C_ACS: nat = 0 in    (* Counter for messages from Customer to ACS *)
    let counter_ACS_C: nat = 0 in    (* Counter for messages from ACS to Customer *)

    (* Step 3: ACS receives transaction details from Customer *)
    in(c, transactionDetailsEnc2: bitstring);
    new n1: nonce;
    let plaintext = aeaddec(keyAC, n1, transactionDetailsEnc2) in
    let messageForACS = fst(plaintext) in
    let signature_C_ACS = snd(plaintext) in
    (* Verify Customer's signature *)
    if checksign(signature_C_ACS, PK_C) = messageForACS then
        let transactionDetailsForACS = fst(messageForACS) in
        let rest1 = snd(messageForACS) in
        let nonceC2_received = fst(rest1) in
        let sender_received = snd(rest1) in
        let SessionID_received = fst(transactionDetailsForACS) in
        let rest2 = snd(transactionDetailsForACS) in
        let M_received = fst(rest2) in
        let counter_C_ACS_received = snd(rest2) in
        if sender_received = C && counter_C_ACS_received = counter_C_ACS then
            (* Increment counter *)
            let counter_C_ACS = counter_C_ACS + 1 in
            (* Check if nonceC2 has been used before *)
            get NonceTableCustomerToACS(nonce, session) suchthat nonce = nonceC2_received && session = SessionID_received in
                event invalid_sender(nonceC2_received);
                0
            else
                insert NonceTableCustomerToACS(nonceC2_received, SessionID_received);
                event receive_transactionDetailsEnc2(transactionDetailsEnc2, nonceC2_received, SessionID_received);
                (* Step 4: ACS sends auth request to Customer *)
                new nonceACS: nonce;       (* Nonce generated by ACS *)
                let authRequestMessage = pair(SessionID_received, pair(ACS, pair(nonceACS, pair(nonceC2_received, counter_ACS_C)))) in
                let signature_ACS = sign(authRequestMessage, SK_ACS) in
                new n2: nonce;
                let authRequestEnc = aeadenc(keyAC, n2, pair(authRequestMessage, signature_ACS)) in
                event send_authRequestEnc(authRequestEnc, nonceC2_received, SessionID_received);
                out(c, authRequestEnc);
                (* Increment counter *)
                let counter_ACS_C = counter_ACS_C + 1 in

                (* Step 5: ACS receives secure code from Customer *)
                in(c, securecodeEnc: bitstring);
                new n3: nonce;
                let plaintext_sec = aeaddec(keyAC, n3, securecodeEnc) in
                let securecodeMessageContent = fst(plaintext_sec) in
                let signature_C_securecode = snd(plaintext_sec) in
                (* Verify Customer's signature *)
                if checksign(signature_C_securecode, PK_C) = securecodeMessageContent then
                    let securecode_received = fst(securecodeMessageContent) in
                    let rest1 = snd(securecodeMessageContent) in
                    let nonceACS_received_sc = fst(rest1) in
                    let rest2 = snd(rest1) in
                    let nonceC3_received = fst(rest2) in
                    let SessionID_received_sc = snd(rest2) in
                    if nonceACS_received_sc = nonceACS && SessionID_received_sc = SessionID_received then
                        (* Check if nonceC3 has been used before *)
                        get NonceTableCustomerToACS(nonce, session) suchthat nonce = nonceC3_received && session = SessionID_received in
                            event invalid_sender(nonceC3_received);
                            0
                        else
                            insert NonceTableCustomerToACS(nonceC3_received, SessionID_received);
                            event receive_securecodeEnc(securecodeEnc, nonceACS_received_sc, SessionID_received_sc);
                            (* Step 6: ACS sends auth response to Customer *)
                            new messageAuth: bitstring;
                            new nonceACS2: nonce;       (* Nonce generated by ACS *)
                            let authResponseMessage = pair(SessionID_received, pair(messageAuth, pair(nonceACS2, pair(nonceACS_received_sc, pair(nonceC3_received, counter_ACS_C))))) in
                            let signature_ACS_resp = sign(authResponseMessage, SK_ACS) in
                            new n4: nonce;
                            let authResponseEnc = aeadenc(keyAC, n4, pair(authResponseMessage, signature_ACS_resp)) in
                            event send_authResponse(authResponseEnc, nonceACS2, SessionID_received);
                            out(c, authResponseEnc);
                            (* Increment counter *)
                            let counter_ACS_C = counter_ACS_C + 1 in
                            0
                    else
                        event invalid_sender(nonceACS_received_sc);
                        0
                else
                    event invalid_signature(signature_C_securecode);
                    0
        else
            event invalid_sender(nonceC2_received);
            0
    else
        event invalid_signature(signature_C_ACS);
        0
    .



(* Security Queries *)
(* Confidentiality Queries *)
query attacker(pan) ==> false.
query attacker(securecode) ==> false.
query attacker(expiry) ==> false.

(* Reachability Queries *)
query x: bitstring; event(invalid_signature(x)) ==> false.
query x: nonce; event(invalid_sender(x)) ==> false.
query event(reach) ==> false.

(* Authentication Queries *)
query nonceC1: nonce, sender: bitstring, SessionID: bitstring, x: bitstring;
  inj-event(receive_purchaseRequestEnc(x, nonceC1, sender, SessionID)) ==>
  inj-event(send_purchaseRequestEnc(x, nonceC1, sender, SessionID)).

query nonceC1: nonce, SessionID: bitstring, x: bitstring;
  inj-event(receive_transactionDetailsEnc(x, nonceC1, SessionID)) ==>
  inj-event(send_transactionDetailsEnc(x, nonceC1, SessionID)).

query nonceC2: nonce, SessionID: bitstring, x: bitstring;
  inj-event(receive_transactionDetailsEnc2(x, nonceC2, SessionID)) ==>
  inj-event(send_transactionDetailsEnc2(x, nonceC2, SessionID)).

query nonceC2: nonce, SessionID: bitstring, x: bitstring;
  inj-event(receive_authRequestEnc(x, nonceC2, SessionID)) ==>
  inj-event(send_authRequestEnc(x, nonceC2, SessionID)).

query nonceACS: nonce, SessionID: bitstring, x: bitstring;
  inj-event(receive_securecodeEnc(x, nonceACS, SessionID)) ==>
  inj-event(send_securecodeEnc(x, nonceACS, SessionID)).

query nonceACS2: nonce, SessionID: bitstring, x: bitstring;
  inj-event(receive_authResponse(x, nonceACS2, SessionID)) ==>
  inj-event(send_authResponse(x, nonceACS2, SessionID)).

query nonceC4: nonce, SessionID: bitstring, x: bitstring;
  inj-event(receive_forward_authResponse(x, nonceC4, SessionID)) ==>
  inj-event(forward_authResponse(x, nonceC4, SessionID)).

query nonceM2: nonce, SessionID: bitstring, x: bitstring;
  inj-event(receive_confirmation(x, nonceM2, SessionID)) ==>
  inj-event(send_confirmation(x, nonceM2, SessionID)).

(* Main Process *)
process
    new keyCM: key;
    new keyAC: key;
    new SK_C: skey;
    let PK_C = pk(SK_C) in out(c, PK_C);
    new SK_M: skey;
    let PK_M = pk(SK_M) in out(c, PK_M);
    new SK_ACS: skey;
    let PK_ACS = pk(SK_ACS) in out(c, PK_ACS);
    (
        !processCustomer(SK_C, PK_M, PK_ACS, keyCM, keyAC) |
        !processMerchant(PK_C, SK_M, PK_ACS, keyCM) |
        !processACS(PK_C, SK_ACS, PK_M, keyAC)
    )
