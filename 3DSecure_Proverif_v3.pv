(* 3D Secure Protocol with Intruder Modeling *)

(* Types *)
type key.
type skey [private].
type pkey.

(* Participants *)
const C: bitstring.       (* Customer *)
const M: bitstring.       (* Merchant *)
const ACS: bitstring.     (* Access Control Server *)

(* Channels *)
free c: channel.
free TLS: channel [private].

(* Cryptographic Primitives *)
fun senc(key, bitstring): bitstring.
reduc forall k: key, m: bitstring; sdec(k, senc(k, m)) = m.

fun pk(skey): pkey.
fun sign(bitstring, skey): bitstring.
reduc forall m: bitstring, sk: skey; checksign(sign(m, sk), pk(sk)) = m.

(* Pairing *)
fun pair(bitstring, bitstring): bitstring.
reduc forall x: bitstring, y: bitstring; fst(pair(x, y)) = x.
reduc forall x: bitstring, y: bitstring; snd(pair(x, y)) = y.

(* Secrets *)
free pan: bitstring [private].
free expiry: bitstring [private].
free securecode: bitstring [private].

(* Tables for Nonce Tracking *)
table NonceTableMerchantToCustomer(bitstring).
table NonceTableCustomerToACS(bitstring).
table NonceTableACSToCustomer(bitstring).
table NonceTableMerchantToACS(bitstring).
table NonceTableCustomerToMerchant(bitstring).
table NonceTableACSToMerchant(bitstring).

(* Events for authentication queries *)
event send_purchaseRequestEnc(bitstring, bitstring, bitstring).
event receive_purchaseRequestEnc(bitstring, bitstring, bitstring).
event send_transactionDetailsEnc(bitstring, bitstring, bitstring).
event receive_transactionDetailsEnc(bitstring, bitstring, bitstring).
event send_transactionDetailsEnc2(bitstring, bitstring, bitstring).
event receive_transactionDetailsEnc2(bitstring, bitstring, bitstring).
event send_authRequestEnc(bitstring, bitstring, bitstring).
event receive_authRequestEnc(bitstring, bitstring, bitstring).
event send_securecodeEnc(bitstring, bitstring, bitstring).
event receive_securecodeEnc(bitstring, bitstring, bitstring).
event forward_authResponse(bitstring, bitstring, bitstring).
event receive_forward_authResponse(bitstring, bitstring, bitstring).
event send_authResponse(bitstring, bitstring, bitstring).
event receive_authResponse(bitstring, bitstring, bitstring).
event send_confirmation(bitstring, bitstring, bitstring).
event receive_confirmation(bitstring, bitstring, bitstring).
event invalid_sender(bitstring).
event invalid_signature(bitstring).
event transactionStart(bitstring).
event transactionEnd(bitstring).
event reach.

(* Customer Process *)
let processCustomer(SK_C: skey, PK_M: pkey, PK_ACS: pkey, keyCM: key, keyAC: key) =
    new SessionID: bitstring;        (* SessionID generated by Customer *)
    new nonceC1: bitstring;          (* Nonce generated by Customer for Merchant *)

    (* Step 0: Customer sends sessionID to Merchant and ACS over encrypted channel*)
    let sessionID_enc_merchant = senc(keyCM, SessionID) in
    let sessionID_enc_acs = senc(keyAC, SessionID) in
    out(TLS, sessionID_enc_merchant);
    out(TLS, sessionID_enc_acs);
    event transactionStart(SessionID);

    (* Step 1: Customer sends purchase request to Merchant *)
    let purchaseRequest = pair(pair(pair(pan, expiry), pair(nonceC1, C)), SessionID) in
    let signature_C = sign(purchaseRequest, SK_C) in
    let purchaseRequestMessage = pair(purchaseRequest, signature_C) in
    let purchaseRequestEnc = senc(keyCM, purchaseRequestMessage) in
    event send_purchaseRequestEnc(purchaseRequestEnc, nonceC1, SessionID);
    out(c, purchaseRequestEnc);

    (* Step 2: Customer receives transaction details from Merchant *)
    in(c, transactionDetailsEnc: bitstring);
    let transactionDetailsMessageDec = sdec(keyCM, transactionDetailsEnc) in
    let transactionDetailsMessage = fst(transactionDetailsMessageDec) in
    let signature_M = snd(transactionDetailsMessageDec) in
    (* Verify Merchant's signature *)
    if checksign(signature_M, PK_M) = transactionDetailsMessage then
        let transactionDetails = fst(transactionDetailsMessage) in
        let SessionID_received = fst(transactionDetails) in
        let nonceM1_nonceC1_received = snd(transactionDetailsMessage) in
        let nonceM1_received = fst(nonceM1_nonceC1_received) in
        let nonceC1_received = snd(nonceM1_nonceC1_received) in
        if nonceC1_received = nonceC1 && SessionID_received = SessionID then
            (* Check if nonceM1 has been used before *)
            get NonceTableMerchantToCustomer(nonce) suchthat nonce = nonceM1_received in
                (* NonceM1 already used, possible replay attack *)
                event invalid_sender(nonceM1_received);
                0
            else
                (* Store nonceM1 in the table *)
                insert NonceTableMerchantToCustomer(nonceM1_received);
                event receive_transactionDetailsEnc(transactionDetailsEnc, nonceC1, SessionID_received);
                (* Step 3: Customer sends transaction details to ACS *)
                new nonceC2: bitstring;        (* Nonce generated by Customer for ACS *)
                let transactionDetailsForACS = pair(pair(transactionDetails, pair(nonceC2, C)), SessionID) in
                let signature_C_ACS = sign(transactionDetailsForACS, SK_C) in
                let transactionDetailsEnc2 = senc(keyAC, pair(transactionDetailsForACS, signature_C_ACS)) in
                event send_transactionDetailsEnc2(transactionDetailsEnc2, nonceC2, SessionID);
                out(c, transactionDetailsEnc2);

                (* Step 4: Customer receives auth request from ACS *)
                in(c, authRequestEnc: bitstring);
                let authRequestMessageDec = sdec(keyAC, authRequestEnc) in
                let authRequestMessage = fst(authRequestMessageDec) in
                let signature_ACS = snd(authRequestMessageDec) in
                (* Verify ACS's signature *)
                if checksign(signature_ACS, PK_ACS) = authRequestMessage then
                    let authRequest = fst(authRequestMessage) in
                    let SessionID_received_ACS = fst(authRequest) in
                    let nonceACS_nonceC2_received = snd(authRequestMessage) in
                    let nonceACS_received = fst(nonceACS_nonceC2_received) in
                    let nonceC2_received = snd(nonceACS_nonceC2_received) in
                    if nonceC2_received = nonceC2 && SessionID_received_ACS = SessionID then
                        (* Check if nonceACS has been used before *)
                        get NonceTableACSToCustomer(nonce) suchthat nonce = nonceACS_received in
                            (* NonceACS already used, possible replay attack *)
                            event invalid_sender(nonceACS_received);
                            0
                        else
                            (* Store nonceACS in the table *)
                            insert NonceTableACSToCustomer(nonceACS_received);
                            event receive_authRequestEnc(authRequestEnc, nonceC2, SessionID_received_ACS);
                            (* Step 5: Customer sends secure code to ACS *)
                            new nonceC3: bitstring;        (* Nonce generated by Customer for ACS *)
                            let securecodeMessage = pair(pair(securecode, nonceACS_received), pair(nonceC3, SessionID)) in
                            let signature_C_securecode = sign(securecodeMessage, SK_C) in
                            let securecodeEnc = senc(keyAC, pair(securecodeMessage, signature_C_securecode)) in
                            event send_securecodeEnc(securecodeEnc, nonceACS_received, SessionID);
                            out(c, securecodeEnc);

                            (* Step 6: Customer receives auth response from ACS *)
                            in(c, authResponseEnc: bitstring);
                            let authResponseMessageDec = sdec(keyAC, authResponseEnc) in
                            let authResponseMessage = fst(authResponseMessageDec) in
                            let signature_ACS_resp = snd(authResponseMessageDec) in
                            (* Verify ACS's signature *)
                            if checksign(signature_ACS_resp, PK_ACS) = authResponseMessage then
                                let authResponse = fst(authResponseMessage) in
                                let SessionID_received_resp = fst(authResponse) in
                                let nonceACS2_nonceACS_nonceC3_received = snd(authResponseMessage) in
                                let nonceACS2_received = fst(nonceACS2_nonceACS_nonceC3_received) in
                                let nonceACS_nonceC3_received = snd(nonceACS2_nonceACS_nonceC3_received) in
                                let nonceACS_received_resp = fst(nonceACS_nonceC3_received) in
                                let nonceC3_received_resp = snd(nonceACS_nonceC3_received) in
                                if (nonceACS_received_resp = nonceACS_received && nonceC3_received_resp = nonceC3 && SessionID_received_resp = SessionID) then
                                    (* Check if nonceACS2 has been used before *)
                                    get NonceTableACSToCustomer(nonce) suchthat nonce = nonceACS2_received in
                                        (* NonceACS2 already used, possible replay attack *)
                                        event invalid_sender(nonceACS2_received);
                                        0
                                    else
                                        insert NonceTableACSToCustomer(nonceACS2_received);
                                        event receive_forward_authResponse(authResponseEnc, nonceACS2_received, SessionID_received_resp);
                                        (* Step 7: Customer sends auth response to Merchant *)
                                        new nonceC4: bitstring;        (* Nonce generated by Customer for Merchant *)
                                        let authResponseForMerchant = pair(authResponseMessage, pair(SessionID, nonceC4)) in
                                        let authResponseEnc2 = senc(keyCM, pair(authResponseForMerchant, signature_ACS_resp)) in
                                        event send_authResponse(authResponseEnc2, nonceACS2_received, SessionID);
                                        out(c, authResponseEnc2);

                                        (* Step 8: Customer receives confirmation from Merchant *)
                                        in(c, confenc: bitstring);
                                        let confirmationMessageDec = sdec(keyCM, confenc) in
                                        let confirmationMessage = fst(confirmationMessageDec) in
                                        let signature_M_conf = snd(confirmationMessageDec) in
                                        (* Verify Merchant's signature *)
                                        if checksign(signature_M_conf, PK_M) = confirmationMessage then
                                            let cconfirmPair = fst(confirmationMessage) in
                                            let cconfirm = fst(cconfirmPair) in
                                            let SessionID_received_conf = snd(cconfirmPair) in
                                            let nonceM2_nonceM1_received = snd(confirmationMessage) in
                                            let nonceM2_received = fst(nonceM2_nonceM1_received) in
                                            let nonceM1_received_conf = snd(nonceM2_nonceM1_received) in
                                            if (nonceM1_received_conf = nonceM1_received && SessionID_received_conf = SessionID) then
                                                (* Check if nonceM2 has been used before *)
                                                get NonceTableMerchantToCustomer(nonce) suchthat nonce = nonceM2_received in
                                                    (* NonceM2 already used, possible replay attack *)
                                                    event invalid_sender(nonceM2_received);
                                                    0
                                                else
                                                    insert NonceTableMerchantToCustomer(nonceM2_received);
                                                    event receive_confirmation(confenc, nonceM2_received, SessionID_received_conf);
                                                    event transactionEnd(SessionID);
                                                    0
                                            else
                                                event invalid_sender(nonceM1_received_conf);
                                                0
                                        else
                                            event invalid_signature(signature_M_conf);
                                            0
                                else
                                    event invalid_sender(nonceACS_received_resp);
                                    0
                            else
                                event invalid_signature(signature_ACS_resp);
                                0
                    else
                        event invalid_sender(nonceC2_received);
                        0
                else
                    event invalid_signature(signature_ACS);
                    0
        else
            event invalid_sender(nonceC1_received);
            0
    else
        event invalid_signature(signature_M);
        0
    .

(* Merchant Process *)
let processMerchant(PK_C: pkey, SK_M: skey, PK_ACS: pkey, keyCM: key) =

    in(TLS, sessionID_enc_merchant: bitstring);
    let SessionID = sdec(keyCM, sessionID_enc_merchant) in

    (* Step 1: Merchant receives purchase request from Customer *)
    in(c, purchaseRequestEnc: bitstring);
    let purchaseRequestMessageDec = sdec(keyCM, purchaseRequestEnc) in
    let purchaseRequest = fst(purchaseRequestMessageDec) in
    let signature_C = snd(purchaseRequestMessageDec) in
    (* Verify Customer's signature *)
    if checksign(signature_C, PK_C) = purchaseRequest then
        let pan_expiry_nonceC1_C = fst(purchaseRequest) in
        if snd(purchaseRequest) = SessionID then
            let pan_expiry = fst(pan_expiry_nonceC1_C) in
            let nonceC1_C = snd(pan_expiry_nonceC1_C) in
            let nonceC1 = fst(nonceC1_C) in
            let sender = snd(nonceC1_C) in
            if sender = C then
                (* Check if nonceC1 has been used before *)
                get NonceTableCustomerToMerchant(nonce) suchthat nonce = nonceC1 in
                    (* NonceC1 already used, possible replay attack *)
                    event invalid_sender(sender);
                    0
                else
                    (* Store nonceC1 in the table *)
                    insert NonceTableCustomerToMerchant(nonceC1);
                    event receive_purchaseRequestEnc(purchaseRequestEnc, nonceC1, SessionID);
                    (* Step 2: Merchant sends transaction details to Customer *)
                    new nonceM1: bitstring;        (* Nonce generated by Merchant *)
                    let transactionDetails = pair(SessionID, M) in
                    let transactionDetailsMessage = pair(transactionDetails, pair(nonceM1, nonceC1)) in
                    let signature_M = sign(transactionDetailsMessage, SK_M) in
                    let transactionDetailsEnc = senc(keyCM, pair(transactionDetailsMessage, signature_M)) in
                    event send_transactionDetailsEnc(transactionDetailsEnc, nonceC1, SessionID);
                    out(c, transactionDetailsEnc);

                    (* Step 7: Merchant receives auth response from Customer *)
                    in(c, authResponseEnc2: bitstring);
                    let authResponseForMerchantDec = sdec(keyCM, authResponseEnc2) in
                    let authResponseForMerchant = fst(authResponseForMerchantDec) in
                    let signature_ACS_resp = snd(authResponseForMerchantDec) in
                    let authResponseMessage = fst(authResponseForMerchant) in
                    (* Verify ACS's signature *)
                    if checksign(signature_ACS_resp, PK_ACS) = authResponseMessage then
                        let SessionID_nonceC4_received = snd(authResponseForMerchant) in
                        let SessionID_received = fst(SessionID_nonceC4_received) in
                        let nonceC4_received = snd(SessionID_nonceC4_received) in
                        let nonceACS2_nonceACS_received = snd(authResponseMessage) in
                        let nonceACS2_received = fst(nonceACS2_nonceACS_received) in
                        let nonceACS_received = snd(nonceACS2_nonceACS_received) in
                        if SessionID_received = SessionID then
                            (* Check if nonceACS2 has been used before *)
                            get NonceTableCustomerToMerchant(nonce) suchthat nonce = nonceC4_received in
                                event invalid_sender(nonceC4_received);
                                0
                            else
                                get NonceTableACSToMerchant(nonce) suchthat nonce = nonceACS2_received in
                                    (* NonceACS2 already used, possible replay attack *)
                                    event invalid_sender(nonceACS2_received);
                                    0
                                else
                                    insert NonceTableACSToMerchant(nonceACS2_received);
                                    event receive_authResponse(authResponseEnc2, nonceACS2_received, SessionID_received);
                                    (* Step 8: Merchant sends confirmation to Customer *)
                                    new cconfirm: bitstring;
                                    new nonceM2: bitstring;        (* Nonce generated by Merchant *)
                                    let confirmationMessage = pair(pair(cconfirm, SessionID), pair(nonceM2, nonceM1)) in
                                    let signature_M_conf = sign(confirmationMessage, SK_M) in
                                    let confenc = senc(keyCM, pair(confirmationMessage, signature_M_conf)) in
                                    event send_confirmation(confenc, nonceM2, SessionID);
                                    out(c, confenc);
                                    0
                        else
                            event invalid_sender(SessionID_received);
                            0
                    else
                        event invalid_signature(signature_ACS_resp);
                        0
            else
                event invalid_sender(sender);
                0
        else
            event invalid_sender(SessionID);
            0
    else
        event invalid_signature(signature_C);
        0
    .

(* ACS Process *)
let processACS(PK_C: pkey, SK_ACS: skey, PK_M: pkey, keyAC: key) =

    (* Step 0: ACS receives sessionID from Customer and Merchant *)
    in(TLS, sessionID_enc_acs: bitstring);
    let SessionID = sdec(keyAC, sessionID_enc_acs) in

    (* Step 3: ACS receives transaction details from Customer *)
    in(c, transactionDetailsEnc2: bitstring);
    let transactionDetailsMessageDec = sdec(keyAC, transactionDetailsEnc2) in
    let transactionDetailsMessage = fst(transactionDetailsMessageDec) in
    let signature_C_ACS = snd(transactionDetailsMessageDec) in
    (* Verify Customer's signature *)
    if checksign(signature_C_ACS, PK_C) = transactionDetailsMessage then
        let transactionDetailsPair = fst(transactionDetailsMessage) in
        if snd(transactionDetailsMessage) = SessionID then
            let transactionDetails = fst(transactionDetailsPair) in
            let nonceC2_sender = snd(transactionDetailsPair) in
            let nonceC2 = fst(nonceC2_sender) in
            let sender = snd(nonceC2_sender) in
            if sender = C then
                (* Check if nonceC2 has been used before *)
                get NonceTableCustomerToACS(nonce) suchthat nonce = nonceC2 in
                    (* NonceC2 already used, possible replay attack *)
                    event invalid_sender(sender);
                    0
                else
                    (* Store nonceC2 in the table *)
                    insert NonceTableCustomerToACS(nonceC2);
                    event receive_transactionDetailsEnc2(transactionDetailsEnc2, nonceC2, SessionID);
                    (* Step 4: ACS sends auth request to Customer *)
                    new nonceACS: bitstring;       (* Nonce generated by ACS *)
                    let authRequest = pair(SessionID, ACS) in
                    let authRequestMessage = pair(authRequest, pair(nonceACS, nonceC2)) in
                    let signature_ACS = sign(authRequestMessage, SK_ACS) in
                    let authRequestEnc = senc(keyAC, pair(authRequestMessage, signature_ACS)) in
                    event send_authRequestEnc(authRequestEnc, nonceC2, SessionID);
                    out(c, authRequestEnc);

                    (* Step 5: ACS receives secure code from Customer *)
                    in(c, securecodeEnc: bitstring);
                    let securecodeMessageDec = sdec(keyAC, securecodeEnc) in
                    let securecodeMessage = fst(securecodeMessageDec) in
                    let signature_C_securecode = snd(securecodeMessageDec) in
                    (* Verify Customer's signature *)
                    if checksign(signature_C_securecode, PK_C) = securecodeMessage then
                        let securecode_nonceACS_received = fst(securecodeMessage) in
                        let nonceC3_SessionID_received = snd(securecodeMessage) in
                        let securecode_received = fst(securecode_nonceACS_received) in
                        let nonceACS_received = snd(securecode_nonceACS_received) in
                        let nonceC3_received = fst(nonceC3_SessionID_received) in
                        let SessionID_received = snd(nonceC3_SessionID_received) in
                        if (nonceACS_received = nonceACS && SessionID_received = SessionID) then
                            get NonceTableCustomerToACS(nonce) suchthat nonce = nonceC3_received in
                                (* NonceACS already used, possible replay attack *)
                                event invalid_sender(nonceC3_received);
                                0
                            else
                                insert NonceTableCustomerToACS(nonceC3_received);
                                event receive_securecodeEnc(securecodeEnc, nonceACS, SessionID_received);
                                (* Step 6: ACS sends auth response to Customer *)
                                new messageAuth: bitstring;
                                new nonceACS2: bitstring;       (* Nonce generated by ACS *)
                                let authResponse = pair(SessionID, messageAuth) in
                                let authResponseMessage = pair(authResponse, pair(nonceACS2, pair(nonceACS, nonceC3_received))) in
                                let signature_ACS_resp = sign(authResponseMessage, SK_ACS) in
                                let authResponseEnc = senc(keyAC, pair(authResponseMessage, signature_ACS_resp)) in
                                event forward_authResponse(authResponseEnc, nonceACS2, SessionID);
                                out(c, authResponseEnc);
                                0
                        else
                            event invalid_sender(nonceACS_received);
                            0
                    else
                        event invalid_signature(signature_C_securecode);
                        0
            else
                event invalid_sender(sender);
                0
        else
            event invalid_sender(SessionID);
            0
    else
        event invalid_signature(signature_C_ACS);
        0
    .

(* Security Queries *)
(* Confidentiality Queries *)
query attacker(pan) ==> false.
query attacker(securecode) ==> false.
query attacker(expiry) ==> false.

weaksecret pan.
weaksecret securecode.
weaksecret expiry.

noninterf pan.
noninterf securecode.
noninterf expiry.

(* Reachability Queries *)
query x:bitstring; event(invalid_signature(x)) ==> false.
query x:bitstring; event(invalid_sender(x)) ==> false.
query x:bitstring; event(transactionEnd(x)) ==> false.

(* Authentication Queries *)
query nonceC1: bitstring, SessionID: bitstring, x: bitstring;
  inj-event(receive_purchaseRequestEnc(x, nonceC1, SessionID)) ==>
  inj-event(send_purchaseRequestEnc(x, nonceC1, SessionID)).

query nonceC1: bitstring, SessionID: bitstring, x: bitstring;
  inj-event(receive_transactionDetailsEnc(x, nonceC1, SessionID)) ==>
  inj-event(send_transactionDetailsEnc(x, nonceC1, SessionID)).

query nonceC2: bitstring, SessionID: bitstring, x: bitstring;
  inj-event(receive_transactionDetailsEnc2(x, nonceC2, SessionID)) ==>
  inj-event(send_transactionDetailsEnc2(x, nonceC2, SessionID)).

query nonceC2: bitstring, SessionID: bitstring, x: bitstring;
  inj-event(receive_authRequestEnc(x, nonceC2, SessionID)) ==>
  inj-event(send_authRequestEnc(x, nonceC2, SessionID)).

query nonceACS: bitstring, SessionID: bitstring, x: bitstring;
  inj-event(receive_securecodeEnc(x, nonceACS, SessionID)) ==>
  inj-event(send_securecodeEnc(x, nonceACS, SessionID)).

query nonceACS: bitstring, SessionID: bitstring, x: bitstring;
    inj-event(receive_forward_authResponse(x, nonceACS, SessionID)) ==>
    inj-event(forward_authResponse(x, nonceACS, SessionID)).

query nonceACS2: bitstring, SessionID: bitstring, x: bitstring;
  inj-event(receive_authResponse(x, nonceACS2, SessionID)) ==>
  inj-event(send_authResponse(x, nonceACS2, SessionID)).

query nonceM2: bitstring, SessionID: bitstring, x: bitstring;
  inj-event(receive_confirmation(x, nonceM2, SessionID)) ==>
  inj-event(send_confirmation(x, nonceM2, SessionID)).

query SessionID: bitstring;
  inj-event(transactionEnd(SessionID)) ==>
  inj-event(transactionStart(SessionID)).

(* Main Process *)
process
    new keyCM: key;
    new keyAC: key;
    new SK_C: skey;
    let PK_C = pk(SK_C) in out(c, PK_C);
    new SK_M: skey;
    let PK_M = pk(SK_M) in out(c, PK_M);
    new SK_ACS: skey;
    let PK_ACS = pk(SK_ACS) in out(c, PK_ACS);
    (
        !processCustomer(SK_C, PK_M, PK_ACS, keyCM, keyAC) |
        !processMerchant(PK_C, SK_M, PK_ACS, keyCM) |
        !processACS(PK_C, SK_ACS, PK_M, keyAC)
    )

(* VERIFICATION RESULTS*)

(*

Verification summary:

Query not attacker(pan[]) is true.

Query not attacker(securecode[]) is true.

Query not attacker(expiry[]) is true.

Weak secret pan is true.

Weak secret securecode is true.

Weak secret expiry is true.

Non-interference pan is true.

Non-interference securecode is true.

Non-interference expiry is true.

Query not event(invalid_signature(x)) is false.

Query not event(invalid_sender(x)) cannot be proved.

Query not event(transactionEnd(x)) is false.

Query inj-event(receive_purchaseRequestEnc(x,nonceC1_2,SessionID_3)) ==> inj-event(send_purchaseRequestEnc(x,nonceC1_2,SessionID_3)) cannot be proved.

Query inj-event(receive_transactionDetailsEnc(x,nonceC1_2,SessionID_3)) ==> inj-event(send_transactionDetailsEnc(x,nonceC1_2,SessionID_3)) is true.

Query inj-event(receive_transactionDetailsEnc2(x,nonceC2_2,SessionID_3)) ==> inj-event(send_transactionDetailsEnc2(x,nonceC2_2,SessionID_3)) cannot be proved.

Query inj-event(receive_authRequestEnc(x,nonceC2_2,SessionID_3)) ==> inj-event(send_authRequestEnc(x,nonceC2_2,SessionID_3)) is true.

Query inj-event(receive_securecodeEnc(x,nonceACS_1,SessionID_3)) ==> inj-event(send_securecodeEnc(x,nonceACS_1,SessionID_3)) is true.

Query inj-event(receive_forward_authResponse(x,nonceACS_1,SessionID_3)) ==> inj-event(forward_authResponse(x,nonceACS_1,SessionID_3)) is true.

Query inj-event(receive_authResponse(x,nonceACS2_1,SessionID_3)) ==> inj-event(send_authResponse(x,nonceACS2_1,SessionID_3)) cannot be proved.

Query inj-event(receive_confirmation(x,nonceM2_1,SessionID_3)) ==> inj-event(send_confirmation(x,nonceM2_1,SessionID_3)) is true.

Query inj-event(transactionEnd(SessionID_3)) ==> inj-event(transactionStart(SessionID_3)) is true.


*)