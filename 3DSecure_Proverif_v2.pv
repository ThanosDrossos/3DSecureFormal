(* 
    3D Secure Protocol Analysis
    ---------------------------
    This code models the 3D Secure authentication protocol using a formal language
    that supports types, constants, functions, equations, processes, and queries.
    The goal is to verify security properties such as the confidentiality of sensitive information and the integrity of authentication mechanisms.

    The protocol involves three participants: Cardholder (C), Merchant (M), and Access Control Server (ACS).

    (c) Thanos Drossos, 2024

*)

(* Types *)
type key.  (* Symmetric keys used for encrypting messages between parties *)
type skey. (* Private keys for asymmetric cryptography *)
type pkey. (* Public keys for asymmetric cryptography *)

(* Participants *)
const C: bitstring.     (* Customer participating in the transaction *)
const M: bitstring.     (* Merchant initiating the transaction *)
const ACS: bitstring.   (* Access Control Server responsible for authentication *)

(* Channel *)
channel c. (* Communication channel between participants *)

(* Bitstring type *)

(* Symmetric encryption *)
fun senc(bitstring, key): bitstring. (* Encrypt bitstring using key *)
fun sdec(bitstring, key): bitstring. (* Decrypt bitstring using key *)

(* Symmetric encryption equations *)

equation forall m: bitstring, k: key; sdec(senc(m, k), k) = m. (* Decryption of an encrypted message using the same key *)

(* Pairing and projections *)
fun pair(bitstring, bitstring): bitstring.
fun fst(bitstring): bitstring.
fun snd(bitstring): bitstring.

equation forall x: bitstring, y: bitstring; fst(pair(x, y)) = x. (*get first element*)
equation forall x: bitstring, y: bitstring; snd(pair(x, y)) = y. (*get second element*)

(* Asymmetric encryption *)

(* Digital signature *)
fun sign(bitstring, skey): bitstring [private].
fun checksign(bitstring, pkey): bitstring.

(* Public key function *)
fun pk(skey): pkey.

(* Signature Verification Property:*)
equation forall m: bitstring, sk: skey, n: bitstring; 
    checksign(sign(pair(m, n), sk), pk(sk)) = pair(m, n).

(* Keys *)
free keyMC: key [private].    (* Shared key between C and M *)
free keyAC: key [private].    (* Shared key between C and ACS *)
free SK_ACS: skey [private].  (* ACS's private signing key *)

(* Constants representing transaction details *)
const city: bitstring.         (* City information *)
const con: bitstring.          (* Country information *)
const curr: bitstring.         (* Currency type *)
const amt: bitstring.          (* Transaction amount *)
const mts: bitstring.          (* Merchant transaction status *)
const brand: bitstring.        (* Card brand *)
const mname: bitstring.        (* Merchant name *)
const mesg: bitstring.         (* Message content *)
const cconfirm: bitstring.     (* Customer confirmation *)

(* Events *)
event aav_generated(bitstring, bitstring).            (* Authentication value and nonce generated by ACS *)
event authentication_verified(bitstring, bitstring). (* Verification of authentication by Merchant *)
event pan_generated(bitstring).                      (* Primary Account Number (PAN) generated by Customer *)
event expiry_generated(bitstring).                   (* Card expiry date generated by Customer *)
event securecode_generated(bitstring).              (* Secure code generated by Customer *)

(* Processes *)

(* 
   Process C (Customer):
   Represents actions taken by the customer during the 3D Secure authentication process.
*)
let C_process =
    new pan: bitstring;
    event pan_generated(pan); (* Log the generation of PAN *)
    new expiry: bitstring;
    event expiry_generated(expiry); (* Log the generation of expiry date *)
    (
        out(c, senc(pair(pan, expiry), keyMC)); (* Purchase request: Send encrypted PAN and expiry date to merchant *)

        in(c, msg2: bitstring); (* Authorization Request: Receive encrypted message from Merchant *)
        let bitstring2 = sdec(msg2, keyMC) in (* Decrypt message (city, con, curr, amt, mts, brand, mname) from Merchant *)
        (
            out(c, senc(bitstring2, keyAC)); (* Foward received message to ACS *)

            in(c, msg3: bitstring); (* Authentication Request: receive encrypted message from ACS *)
            let bitstring3 = sdec(msg3, keyAC) in (* Decrypt response (mname, amt, pan, mesg, expiry) from ACS *)
            (
                new securecode: bitstring;
                event securecode_generated(securecode); (* Log the generation of secure code *)
                (
                    out(c, senc(securecode, keyAC)); (* Authentication Response: Send securecode to ACS *)

                    in(c, msg5: bitstring); (*Authorization Response*)
                    let bitstring5 = sdec(msg5, keyAC) in (* Decrypt message from ACS *)
                    (
                        let avalue: bitstring = fst(bitstring5) in
                        let signature: bitstring = snd(bitstring5) in 
                        (
                            out(c, senc(pair(avalue, signature), keyMC)); (* Send authentication value and signature to merchant *)

                            in(c, msg6: bitstring); (* Payment Confirmation *)
                            let bitstring6 = sdec(msg6, keyMC) in (* Decrypt message *)
                            0
                        )
                    )
                )
            )
        )
    ).

(* 
   Process M (Merchant):
   Represents the actions taken by the merchant during the 3D Secure authentication process.
*)
let M_process =
    in(c, msg1: bitstring); (* Purchase Request: Receive encrypted PAN and expiry date *)
    let pan_expiry = sdec(msg1, keyMC) in (* Decrypt the PAN and expiry date *)
    (
        let pan: bitstring = fst(pan_expiry) in (* Extract PAN *)
        let expiry: bitstring = snd(pan_expiry) in (* Extract expiry date *)
        (
            let bitstring2 = pair(city, pair(con, pair(curr, pair(amt, pair(mts, pair(brand, pair(pan, pair(expiry, mname)))))))) in
            out(c, senc(bitstring2, keyMC)); (* Send transaction details to Customer *)

            in(c, msg5a: bitstring); (*Authorization Response*)
            let bitstring5a = sdec(msg5a, keyMC) in (* Decrypt the authentication value and signature *)
            (
                let avalue: bitstring = fst(bitstring5a) in
                let signature: bitstring = snd(bitstring5a) in
                (
                    let (aav_received: bitstring, nonce_received: bitstring) = checksign(signature, pk(SK_ACS)) in
                    event authentication_verified(aav_received, nonce_received); (* Log authentication verification *)

                    let bitstring6 = pair(cconfirm, pair(mname, amt)) in
                    out(c, senc(bitstring6, keyMC)); (* Send confirmation to Customer *)
                    0
                )
            )
        )
    ).

(* Process ACS *)
let ACS_process =
    in(c, msg2a: bitstring); (* Receive encrypted data from customer *)
    let bitstring2 = sdec(msg2a, keyAC) in (* Decrypt the data using common key*)
    let (city_var: bitstring, rest1: bitstring) = bitstring2 in
    let (con_var: bitstring, rest2: bitstring) = rest1 in
    let (curr_var: bitstring, rest3: bitstring) = rest2 in
    let (amt_var: bitstring, rest4: bitstring) = rest3 in
    let (mts_var: bitstring, rest5: bitstring) = rest4 in
    let (brand_var: bitstring, rest6: bitstring) = rest5 in
    let (pan_var: bitstring, rest7: bitstring) = rest6 in
    let (expiry_var: bitstring, mname_var: bitstring) = rest7 in
    (
        let bitstring3 = pair(mname_var, pair(amt_var, pair(pan_var, pair(mesg, expiry_var)))) in
        out(c, senc(bitstring3, keyAC)); (* Encrypt and Send message to Customer *)

        in(c, msg4: bitstring); (* Receive secure code from Customer *)
        let securecode = sdec(msg4, keyAC) in (* Decrypt secure code *)
        (
            new aav: bitstring; (* Generate authentication value *)
            new nonce: bitstring;  (* Generate nonce *)
            event aav_generated(aav, nonce); (* Log authentication value and nonce *)

            let signature: bitstring = sign(pair(aav, nonce), SK_ACS) in (* Sign the authentication value and nonce *)
            (
                let bitstring5 = pair(aav, signature) in 
                out(c, senc(bitstring5, keyAC)); (* Encrypt and send signature back to customer *)
                0
            )
        )
    ).

(* Queries for Security Verification *)

(* 
   Query: Can an attacker obtain the PAN submitted by the Customer?
   Ensures that the PAN remains confidential and cannot be derived by an attacker.
*)
query pan: bitstring; event(pan_generated(pan)) ==> attacker(pan).
(* 
   Query: Can an attacker obtain the card expiry date?
*)
query expiry: bitstring; event(expiry_generated(expiry)) ==> attacker(expiry).
(* 
   Query: Can an attacker obtain the secure code?
*)
query securecode: bitstring; event(securecode_generated(securecode)) ==> attacker(securecode).
(* 
   Query: Does the verification of authentication by the Merchant imply that the AAV was generated by the ACS?
   Ensures the integrity of the authentication process.
*)
query aav: bitstring, n: bitstring; inj-event(authentication_verified(aav, n)) ==> inj-event(aav_generated(aav, n)).

(* Main process *)
process
    (
        (C_process) |
        (M_process) |
        (ACS_process)
    )


(*Results:

   - The queries for PAN, expiry, and secure code confidentiality cannot be proved by an attacker.
   - The authentication verification correctly implies that the AAV was generated by the ACS.
*)

(* OUTPUT *)

(* 
Completing equations...
-- Process 1-- Query event(pan_generated(pan_2)) ==> attacker(pan_2) in process 1
Translating the process into Horn clauses...
select mess(c[],msg2_1)/-5000
select mess(c[],senc(pair(pan_2,y),keyMC[]))/-5000
select mess(c[],senc(pan_expiry_1,keyMC[]))/-5000
Completing...
select mess(c[],senc(pair(x,*signature_3),keyMC[]))/-5000
select mess(c[],senc(pair(avalue_2,y),keyMC[]))/-5000
Starting query event(pan_generated(pan_2)) ==> attacker(pan_2)
Inside query: trying to prove attacker(pan[])
Completing...
Inside query: proof failed
goal reachable: event(pan_generated(pan[]))
RESULT event(pan_generated(pan_2)) ==> attacker(pan_2) cannot be proved.
-- Query event(expiry_generated(expiry_2)) ==> attacker(expiry_2) in process 1
Translating the process into Horn clauses...
select mess(c[],msg2_1)/-5000
select mess(c[],senc(pair(pan_2,y),keyMC[]))/-5000
select mess(c[],senc(pan_expiry_1,keyMC[]))/-5000
Completing...
select mess(c[],senc(pair(x,*signature_3),keyMC[]))/-5000
select mess(c[],senc(pair(avalue_2,y),keyMC[]))/-5000
Starting query event(expiry_generated(expiry_2)) ==> attacker(expiry_2)
Inside query: trying to prove attacker(expiry[])
Completing...
Inside query: proof failed
goal reachable: event(expiry_generated(expiry[]))
RESULT event(expiry_generated(expiry_2)) ==> attacker(expiry_2) cannot be proved.
-- Query event(securecode_generated(securecode_2)) ==> attacker(securecode_2) in process 1
Translating the process into Horn clauses...
select mess(c[],msg2_1)/-5000
select mess(c[],senc(pair(pan_2,y),keyMC[]))/-5000
select mess(c[],senc(pan_expiry_1,keyMC[]))/-5000
Completing...
select mess(c[],senc(pair(x,*signature_3),keyMC[]))/-5000
select mess(c[],senc(pair(avalue_2,y),keyMC[]))/-5000
Starting query event(securecode_generated(securecode_2)) ==> attacker(securecode_2)
Inside query: trying to prove attacker(securecode[msg3 = msg3_1,msg2 = msg2_1]) from mess(c[],msg3_1) && mess(c[],msg2_1)
Completing...
Inside query: proof failed
goal reachable: mess(c[],msg3_1) && mess(c[],msg2_1) -> event(securecode_generated(securecode_2))
Abbreviations:
securecode_2 = securecode[msg3 = msg3_1,msg2 = msg2_1]
RESULT event(securecode_generated(securecode_2)) ==> attacker(securecode_2) cannot be proved.
-- Query inj-event(authentication_verified(aav_1,n)) ==> inj-event(aav_generated(aav_1,n)) in process 1
Translating the process into Horn clauses...
select attacker(senc(pair(pan_2,y),keyMC[]))/-5000
select attacker(senc(pan_expiry_1,keyMC[]))/-5000
Completing...
select attacker(senc(pair(x,*signature_3),keyMC[]))/-5000
select attacker(senc(pair(avalue_2,y),keyMC[]))/-5000
Starting query inj-event(authentication_verified(aav_1,n)) ==> inj-event(aav_generated(aav_1,n))
RESULT inj-event(authentication_verified(aav_1,n)) ==> inj-event(aav_generated(aav_1,n)) is true.
--------------------------------------------------------------
Verification summary:
Query event(pan_generated(pan_2)) ==> attacker(pan_2) cannot be proved.
Query event(expiry_generated(expiry_2)) ==> attacker(expiry_2) cannot be proved.
Query event(securecode_generated(securecode_2)) ==> attacker(securecode_2) cannot be proved.
Query inj-event(authentication_verified(aav_1,n)) ==> inj-event(aav_generated(aav_1,n)) is true.
--------------------------------------------------------------
*)