(* 3D Secure Protocol with Intruder Modeling *)

(* Types *)
type key.
type skey [private].
type pkey.

(* Participants *)
const C: bitstring.       (* Customer *)
const M: bitstring.       (* Merchant *)
const ACS: bitstring.     (* Access Control Server *)

(* Channel *)
channel c.

(* Cryptographic Primitives *)
fun senc(key, bitstring): bitstring.
reduc forall k: key, m: bitstring; sdec(k, senc(k, m)) = m.

fun pk(skey): pkey.
fun sign(bitstring, skey): bitstring.
reduc forall m: bitstring, sk: skey; checksign(sign(m, sk), pk(sk)) = m.

(* Pairing *)
fun pair(bitstring, bitstring): bitstring.
reduc forall x: bitstring, y: bitstring; fst(pair(x, y)) = x.
reduc forall x: bitstring, y: bitstring; snd(pair(x, y)) = y.

(* Secrets *)
free pan: bitstring [private].
free expiry: bitstring [private].
free securecode: bitstring [private].

(* Tables for Nonce Tracking *)
table NonceTableMerchant(bitstring).
table NonceTableACS(bitstring).
table NonceTableCustomer(bitstring).

(* Events for authentication queries *)
event send_purchaseRequestEnc(bitstring, bitstring, bitstring).
event receive_purchaseRequestEnc(bitstring, bitstring, bitstring).
event send_transactionDetailsEnc(bitstring, bitstring).
event receive_transactionDetailsEnc(bitstring, bitstring).
event send_transactionDetailsEnc2(bitstring, bitstring).
event receive_transactionDetailsEnc2(bitstring, bitstring).
event send_authRequestEnc(bitstring, bitstring).
event receive_authRequestEnc(bitstring, bitstring).
event send_securecodeEnc(bitstring, bitstring).
event receive_securecodeEnc(bitstring, bitstring).
event send_authResponse(bitstring, bitstring).
event receive_authResponse(bitstring, bitstring).
event send_confirmation(bitstring, bitstring).
event receive_confirmation(bitstring, bitstring).
event invalid_sender(bitstring).
event invalid_signature(bitstring).
event reach.

(* Customer Process *)
let processCustomer(SK_C: skey, PK_M: pkey, PK_ACS: pkey, keyCM: key, keyAC: key) =
    new nonceC1: bitstring;        (* Nonce generated by Customer for Merchant *)
    
    (* Step 1: Customer sends purchase request to Merchant *)
    let purchaseRequest = pair(pair(pan, expiry), pair(nonceC1, C)) in
    let signature_C = sign(purchaseRequest, SK_C) in
    let purchaseRequestMessage = pair(purchaseRequest, signature_C) in
    let purchaseRequestEnc = senc(keyCM, purchaseRequestMessage) in
    event send_purchaseRequestEnc(purchaseRequestEnc, nonceC1, C);
    out(c, purchaseRequestEnc);

    (* Step 2: Customer receives transaction details from Merchant *)
    in(c, transactionDetailsEnc: bitstring);
    let transactionDetailsMessageDec = sdec(keyCM, transactionDetailsEnc) in
    let transactionDetailsMessage = fst(transactionDetailsMessageDec) in
    let signature_M = snd(transactionDetailsMessageDec) in
    (* Verify Merchant's signature *)
    if checksign(signature_M, PK_M) = transactionDetailsMessage then
        let transactionDetails = fst(transactionDetailsMessage) in
        let nonceM1 = fst(transactionDetails) in
        let merchantDetails = snd(transactionDetails) in
        let nonceC1_received = snd(transactionDetailsMessage) in
        if nonceC1_received = nonceC1 then
            (* Check if nonceM1 has been used before *)
            get NonceTableCustomer(nonce) suchthat nonce=nonceM1 in
                (* NonceM1 already used, possible replay attack *)
                event invalid_sender(nonceM1);
                0
            else
                (* Store nonceM1 in the table *)
                insert NonceTableCustomer(nonceM1);
                event receive_transactionDetailsEnc(transactionDetailsEnc, nonceC1);
                (* Step 3: Customer sends transaction details to ACS *)
                new nonceC2: bitstring;        (* Nonce generated by Customer for ACS *)
                let transactionDetailsForACS = pair(transactionDetails, pair(nonceC2, C)) in
                let signature_C_ACS = sign(transactionDetailsForACS, SK_C) in
                let transactionDetailsEnc2 = senc(keyAC, pair(transactionDetailsForACS, signature_C_ACS)) in
                event send_transactionDetailsEnc2(transactionDetailsEnc2, nonceC2);
                out(c, transactionDetailsEnc2);

                (* Step 4: Customer receives auth request from ACS *)
                in(c, authRequestEnc: bitstring);
                let authRequestMessageDec = sdec(keyAC, authRequestEnc) in
                let authRequestMessage = fst(authRequestMessageDec) in
                let signature_ACS = snd(authRequestMessageDec) in
                (* Verify ACS's signature *)
                if checksign(signature_ACS, PK_ACS) = authRequestMessage then
                    let authRequest = fst(authRequestMessage) in
                    let nonceC2_received = snd(authRequestMessage) in
                    if nonceC2_received = nonceC2 then
                        let nonceACS = fst(authRequest) in
                        let acsDetails = snd(authRequest) in
                        (* Check if nonceACS has been used before *)
                        get NonceTableCustomer(nonce) suchthat nonce = nonceACS in
                            (* NonceACS already used, possible replay attack *)
                            event invalid_sender(nonceACS);
                            0
                        else
                            (* Store nonceACS in the table *)
                            insert NonceTableCustomer(nonceACS);
                            event receive_authRequestEnc(authRequestEnc, nonceC2);
                            (* Step 5: Customer sends secure code to ACS *)
                            let securecodeMessage = pair(securecode, nonceACS) in
                            let signature_C_securecode = sign(securecodeMessage, SK_C) in
                            let securecodeEnc = senc(keyAC, pair(securecodeMessage, signature_C_securecode)) in
                            event send_securecodeEnc(securecodeEnc, nonceACS);
                            out(c, securecodeEnc);

                            (* Step 6: Customer receives auth response from ACS *)
                            in(c, authResponseEnc: bitstring);
                            let authResponseMessageDec = sdec(keyAC, authResponseEnc) in
                            let authResponseMessage = fst(authResponseMessageDec) in
                            let signature_ACS_resp = snd(authResponseMessageDec) in
                            (* Verify ACS's signature *)
                            if checksign(signature_ACS_resp, PK_ACS) = authResponseMessage then
                                let authResponse = fst(authResponseMessage) in
                                let nonceACS_received = snd(authResponseMessage) in
                                get NonceTableCustomer(nonce) suchthat nonce = nonceACS_received in
                                    (* NonceACS already used, possible replay attack *)
                                    event invalid_sender(nonceACS_received);
                                    0
                                else
                                    event receive_authResponse(authResponseEnc, nonceACS);
                                    (* Step 7: Customer sends auth response to Merchant *)
                                    let authResponseEnc2 = senc(keyCM, pair(authResponseMessage, signature_ACS_resp)) in
                                    out(c, authResponseEnc2);

                                    (* Step 8: Customer receives confirmation from Merchant *)
                                    in(c, confenc: bitstring);
                                    let confirmationMessageDec = sdec(keyCM, confenc) in
                                    let confirmationMessage = fst(confirmationMessageDec) in
                                    let signature_M_conf = snd(confirmationMessageDec) in
                                    (* Verify Merchant's signature *)
                                    if checksign(signature_M_conf, PK_M) = confirmationMessage then
                                        let cconfirm = fst(confirmationMessage) in
                                        let nonceM2_received = snd(confirmationMessage) in
                                        
                                        get NonceTableCustomer(nonce) suchthat nonce = nonceM2_received in
                                            event invalid_sender(nonceM2_received);
                                            0
                                        else
                                            insert NonceTableCustomer(nonceM2_received);
                                            event receive_confirmation(confenc, nonceM2_received);
                                            event reach;
                                            0
                                    else
                                        event invalid_signature(signature_M_conf);
                                        0
                            else
                                event invalid_signature(signature_ACS_resp);
                                0
                    else
                        event invalid_sender(nonceC2_received);
                        0
                else
                    event invalid_signature(signature_ACS);
                    0
        else
            event invalid_sender(nonceC1_received);
            0
    else
        event invalid_signature(signature_M);
        0
    .

(* Merchant Process *)
let processMerchant(PK_C: pkey, SK_M: skey, PK_ACS: pkey, keyCM: key) =

    (* Step 1: Merchant receives purchase request from Customer *)
    in(c, purchaseRequestEnc: bitstring);
    let purchaseRequestMessageDec = sdec(keyCM, purchaseRequestEnc) in
    let purchaseRequestMessage = fst(purchaseRequestMessageDec) in
    let signature_C = snd(purchaseRequestMessageDec) in
    (* Verify Customer's signature *)
    if checksign(signature_C, PK_C) = purchaseRequestMessage then
        let purchaseRequest = fst(purchaseRequestMessage) in
        let nonceC1_sender = snd(purchaseRequestMessage) in
        let pan_expiry = fst(purchaseRequest) in
        let nonceC1 = fst(nonceC1_sender) in
        let sender = snd(nonceC1_sender) in
        if sender = C then
            (* Check if nonceC1 has been used before *)
            get NonceTableMerchant(nonce) suchthat nonce = nonceC1 in
                (* NonceC1 already used, possible replay attack *)
                event invalid_sender(sender);
                0
            else
                (* Store nonceC1 in the table *)
                insert NonceTableMerchant(nonceC1);
                event receive_purchaseRequestEnc(purchaseRequestEnc, nonceC1, sender);
                (* Step 2: Merchant sends transaction details to Customer *)
                new nonceM1: bitstring;        (* Nonce generated by Merchant *)
                let transactionDetails = pair(nonceM1, M) in
                let transactionDetailsMessage = pair(transactionDetails, nonceC1) in
                let signature_M = sign(transactionDetailsMessage, SK_M) in
                let transactionDetailsEnc = senc(keyCM, pair(transactionDetailsMessage, signature_M)) in
                event send_transactionDetailsEnc(transactionDetailsEnc, nonceC1);
                out(c, transactionDetailsEnc);

                (* Step 7: Merchant receives auth response from Customer *)
                in(c, authResponseEnc2: bitstring);
                let authResponseMessageDec = sdec(keyCM, authResponseEnc2) in
                let authResponseMessage = fst(authResponseMessageDec) in
                let signature_ACS_resp = snd(authResponseMessageDec) in
                (* Verify ACS's signature *)
                if checksign(signature_ACS_resp, PK_ACS) = authResponseMessage then
                    let authResponse = fst(authResponseMessage) in
                    let nonceACS2 = snd(authResponseMessage) in
                    get NonceTableMerchant(nonce) suchthat nonce = nonceACS2 in
                        event invalid_sender(nonceACS2);
                        0
                    else 
                        (* Step 8: Merchant sends confirmation to Customer *)
                        new cconfirm: bitstring;
                        new nonceM2: bitstring;        (* Nonce generated by Merchant *)
                        let confirmationMessage = pair(cconfirm, nonceM2) in
                        let signature_M_conf = sign(confirmationMessage, SK_M) in
                        let confenc = senc(keyCM, pair(confirmationMessage, signature_M_conf)) in
                        out(c, confenc);
                        event send_confirmation(confenc, nonceM2);
                        0
                else
                    event invalid_signature(signature_ACS_resp);
                    0
        else
            event invalid_sender(sender);
            0
    else
        event invalid_signature(signature_C);
        0
    .

(* ACS Process *)
let processACS(PK_C: pkey, SK_ACS: skey, PK_M: pkey, keyAC: key) =

    (* Step 3: ACS receives transaction details from Customer *)
    in(c, transactionDetailsEnc2: bitstring);
    let transactionDetailsMessageDec = sdec(keyAC, transactionDetailsEnc2) in
    let transactionDetailsMessage = fst(transactionDetailsMessageDec) in
    let signature_C_ACS = snd(transactionDetailsMessageDec) in
    (* Verify Customer's signature *)
    if checksign(signature_C_ACS, PK_C) = transactionDetailsMessage then
        let transactionDetails = fst(transactionDetailsMessage) in
        let nonceC2_sender = snd(transactionDetailsMessage) in
        let nonceC2 = fst(nonceC2_sender) in
        let sender = snd(nonceC2_sender) in
        if sender = C then
            (* Check if nonceC2 has been used before *)
            get NonceTableACS(nonce) suchthat nonce = nonceC2 in
                (* NonceC2 already used, possible replay attack *)
                event invalid_sender(sender);
                0
            else
                (* Store nonceC2 in the table *)
                insert NonceTableACS(nonceC2);
                event receive_transactionDetailsEnc2(transactionDetailsEnc2, nonceC2);
                (* Step 4: ACS sends auth request to Customer *)
                new nonceACS: bitstring;       (* Nonce generated by ACS *)
                let authRequest = pair(nonceACS, ACS) in
                let authRequestMessage = pair(authRequest, nonceC2) in
                let signature_ACS = sign(authRequestMessage, SK_ACS) in
                let authRequestEnc = senc(keyAC, pair(authRequestMessage, signature_ACS)) in
                event send_authRequestEnc(authRequestEnc, nonceC2);
                out(c, authRequestEnc);

                (* Step 5: ACS receives secure code from Customer *)
                in(c, securecodeEnc: bitstring);
                let securecodeMessageDec = sdec(keyAC, securecodeEnc) in
                let securecodeMessage = fst(securecodeMessageDec) in
                let signature_C_securecode = snd(securecodeMessageDec) in
                (* Verify Customer's signature *)
                if checksign(signature_C_securecode, PK_C) = securecodeMessage then
                    let securecode_received = fst(securecodeMessage) in
                    let nonceACS_received = snd(securecodeMessage) in
                    if nonceACS_received = nonceACS then
                        event receive_securecodeEnc(securecodeEnc, nonceACS);
                        (* Step 6: ACS sends auth response to Customer *)
                        new messageAuth: bitstring;
                        new nonceACS2: bitstring;       (* Nonce generated by ACS *)
                        let authResponseMessage = pair(messageAuth, nonceACS2) in
                        let signature_ACS_resp = sign(authResponseMessage, SK_ACS) in
                        let authResponseEnc = senc(keyAC, pair(authResponseMessage, signature_ACS_resp)) in
                        event send_authResponse(authResponseEnc, nonceACS2);
                        out(c, authResponseEnc);
                        0
                    else
                        event invalid_sender(nonceACS_received);
                        0
                else
                    event invalid_signature(signature_C_securecode);
                    0
        else
            event invalid_sender(sender);
            0
    else
        event invalid_signature(signature_C_ACS);
        0
    .

(* Security Queries *)
(* Confidentiality Queries *)
query attacker(pan) ==> false.
query attacker(securecode) ==> false.
query attacker(expiry) ==> false.

(* Integrity Queries *)
query x:bitstring; event(invalid_signature(x)) ==> false.
query x:bitstring; event(invalid_sender(x)) ==> false.
query event(reach) ==> false.

(* Authentication Queries *)
query nonceC1: bitstring, sender: bitstring, x: bitstring;
  inj-event(receive_purchaseRequestEnc(x, nonceC1, sender)) ==>
  inj-event(send_purchaseRequestEnc(x, nonceC1, sender)).

query nonceC1: bitstring, x: bitstring;
  inj-event(receive_transactionDetailsEnc(x, nonceC1)) ==>
  inj-event(send_transactionDetailsEnc(x, nonceC1)).

query nonceC2: bitstring, x: bitstring;
  inj-event(receive_transactionDetailsEnc2(x, nonceC2)) ==>
  inj-event(send_transactionDetailsEnc2(x, nonceC2)).

query nonceC2: bitstring, x: bitstring;
  inj-event(receive_authRequestEnc(x, nonceC2)) ==>
  inj-event(send_authRequestEnc(x, nonceC2)).

query nonceACS: bitstring, x: bitstring;
  inj-event(receive_securecodeEnc(x, nonceACS)) ==>
  inj-event(send_securecodeEnc(x, nonceACS)).

query nonceACS: bitstring, x: bitstring;
  inj-event(receive_authResponse(x, nonceACS)) ==>
  inj-event(send_authResponse(x, nonceACS)).

query nonceM2: bitstring, x: bitstring;
    inj-event(receive_confirmation(x, nonceM2)) ==>
    inj-event(send_confirmation(x, nonceM2)).

(* Main Process *)
process
    new keyCM: key;
    new keyAC: key;
    new SK_C: skey;
    let PK_C = pk(SK_C) in out(c, PK_C);
    new SK_M: skey;
    let PK_M = pk(SK_M) in out(c, PK_M);
    new SK_ACS: skey;
    let PK_ACS = pk(SK_ACS) in out(c, PK_ACS);
    (
        !processCustomer(SK_C, PK_M, PK_ACS, keyCM, keyAC) |
        !processMerchant(PK_C, SK_M, PK_ACS, keyCM) |
        !processACS(PK_C, SK_ACS, PK_M, keyAC)
    )
